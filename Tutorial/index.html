<html>
<head>
<link type="text/css" rel="stylesheet" href="http://www.codeproject.com/App_Themes/NetCommunity/CodeProject.css" />
</head>
<body>
<!-- Article Starts --> 
 
<UL class=download>
<LI>Download SharpPcap source code and examples or binaries at the <a href="http://sourceforge.net/projects/sharppcap/">SharpPcap SourceForge project page</a> and check out the <a href="http://sourceforge.net/apps/mediawiki/sharppcap/index.php">SharpPcap home page</a></li> 
<P><IMG height=279 src="sharppcap/SharpPcap.png" width=600></P> 
<P><SMALL>[A .NET sniffer application written with SharpPcap]</SMALL></P> 
<H2>Introduction</H2>
<P>Packet capturing (or packet sniffing) is the process of collecting all packets of data that pass through a given network interface. Capturing network packets in our applications is a powerful capability which lets us write network monitoring, packet analyzers and security tools. The <A href="http://www.tcpdump.org/" target=_blank>libpcap</A> library for UNIX based systems and <A href="http://www.winpcap.org/" target=_blank>WinPcap</A> for Windows are the most widely used packet capture drivers that provide API for low-level network monitoring. Among the applications that use libpcap/WinPcap as its packet capture subsystem are the famous <A href="http://www.tcpdump.org/" target=_blank>tcpdump</A> and <A href="http://www.wireshark.org/" target=_blank>Wireshark</A>.</P> 
<P>In this article, we will introduce the <A href="http://sourceforge.net/projects/sharppcap" target=_blank>SharpPcap</A> .NET assembly (library) for interfacing with libpcap or winpcap from your .NET application and will give you a detailed programming tutorial on how to use it.</P> 
<H2>Background</H2>
<P>Tamir Gal started the SharpPcap project around 2004. He wanted to use WinPcap in a .NET application while working on his final project for university. The project involved analyzing and decoding VoIP traffic and he wanted to keep coding simple with C# which has time saving features like garbage collection. Accessing the WinPcap API from .NET seemed to be quite a popular requirement, and he found some useful projects on CodeProject's website that let you do just that:</P> 
<UL> 
<LI><A href="http://www.codeproject.com/csharp/pacanal.asp">Packet Capture and Analayzer</A> 
<LI><A href="http://www.codeproject.com/csharp/pktcap.asp">Raw Socket Capturing Using C#</A> 
<LI><A href="http://www.codeproject.com/dotnet/dotnetwinpcap.asp">Packet sniffing with winpcap functions ported to a .NET library</A> </LI></UL> 
<P>The first project is a great ethereal .NET clone that lets you capture and analyze numerous types of protocol packets. However, a few issues with this project make it almost impossible to be shared among other .NET applications. Firstly, the author did not provide any generic API for capturing packets that can be used by other .NET applications. He didn't separate his UI code and his analyzing and capturing code, making his capturing code depend on the GUI classes such as <CODE>ListView</CODE> to operate. Secondly, for some reason the author chose to re-implement some of WinPcap's functions in C# by himself rather than just wrapping them. This means that his application can't take advantage of the new WinPcap versions since he hard coded a certain version of WinPcap in his application.</P> 
<P>The second and the third articles are nice starts for wrapper projects for WinPcap, however they didn't provide some important WinPcap features such as handling offline pcap files and applying kernel-level packet filters, and most importantly they provide no parser classes for analyzing protocol packets. Both projects didn't post their library source code together with the article in order to let other people extend their work and add new features and new packet parser classes.</P> 
<P>And so, Tamir decided to start his own library for the task. Several versions in the 1.x series were released. Development slowed towards mid-2007 when the last version in the 1.x series was released, SharpPcap 1.6.2.</P>
<P>Chris Morgan took over development of SharpPcap in November of 2008. Since then SharpPcap has had major internal rewrites and API improvements.</p>
<P>In late February 2010 SharpPcap v3.0 was released. This release represents a rewrite of SharpPcap's packet parsers. Packet parsing functionality was broken out into a new library, <a href="http://packetnet.sf.net">Packet.Net</a>. SharpPcap takes care of interfacing with libpcap/winpcap and Packet.Net takes care of packet dissection and creation. The details of Packet.Net's architecture will be discussed later in the turotial.</p>
<H2>About SharpPcap</H2> 
<P>The purpose of <A href="http://sourceforge.net/projects/sharppcap" target=_blank>SharpPcap</A> is to provide a framework for capturing, injecting and analyzing network packets for .NET applications.</p>
<p>SharpPcap is openly and actively developed with its source code and file releases hosted on SourceForge. Source code patches to improve or fix issues are welcome via the <a href="http://lists.sourceforge.net/lists/listinfo/sharppcap-devel">sharppcap developers mailing list</a>. Bug reports, feature requests and other queries are actively answered on the support forums and issue trackers there so if you have any trouble with the library please feel free to ask.</p>
<p>SharpPcap is a fully managed cross platform library. The same assembly runs under Microsoft .NET as well as <a href="http://mono-project.com">Mono</a> on both 32 and 64bit platforms.</p>
<p>The following list illustrates the features currently supported by SharpPcap:</P> 
<UL>
<LI><b>Single assembly</b> for <b>Microsoft .NET</b> and <b>Mono</b> platforms on <i>Windows (32 or 64bit)</i>, <i>Linux (32 or 64bit)</i> and <i>Mac</i>.</li>
<li>High performance - SharpPcap can capture fast enough to keep up with >3MB/s scp transfer rates</li>
<li>WinPcap extensions are partially supported
<ul>
<li>Setting the kernel buffer size</li>
<LI>Injecting packets using send queues.</li>
<LI>Collecting network statistics on a given network interface</LI>
</ul>
</li>
<LI>Enumerating and showing details about the physical network interface on a Windows machine.</li> 
<LI>Capturing low-level network packets going through a given interface.</li> 
<LI>Analyzing and parsing the following protocols: <I><a href="http://en.wikipedia.org/wiki/Ethernet#Ethernet_frame_types_and_the_EtherType_field">Ethernet</a></I>,
<I><a href="http://wiki.wireshark.org/SLL LinuxSLL">Linux SLL</a></i>
<I><a href="http://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a></I>,
<I>IP (<a href="http://en.wikipedia.org/wiki/IPv4">IPv4</a> and <a href="http://en.wikipedia.org/wiki/IPv6">IPv6</a>)</I>,
<I><a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a></I>,
<I><a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a></I>,
<I><a href="http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMPv4</a></I>,
<I><a href="http://en.wikipedia.org/wiki/ICMPv6">ICMPv6</a></I>,
<I><a href="http://en.wikipedia.org/wiki/IGMP">IGMPv2</a></I>,
<I><a href="http://en.wikipedia.org/wiki/Pppoe">PPPoE</a></i>,
<i><a href="http://en.wikipedia.org/wiki/Point-to-Point_Protoco">PTP</a></i>,
<i>LLDP</i>.</li> 
<LI>Injecting low-level network packets on a given interface.</li> 
<LI>Handling (reading and writing) offline packet capture files.</li>
<li>Retrieving adapter statistics on packets received vs. dropped</li>
</UL> 
<P>Please check the project homepage <A href="http://sourceforge.net/projects/sharppcap" target=_blank>homepage</A> for the latest updates and bug fixes.</P> 
<H2>Packet.Net architecture and usage</h2>
<P>If you are familiar with SharpPcap you may recall that SharpPcap used an inheritance model. Tcp packets were represented by a class of type TCPPacket that inherited from IPPacket. IPPacket inherited from EthernetPacket and EthernetPacket inherited from the base packet class. This is convienent as each Tcp packet would have properties for Tcp fields, Ip fields and Ethernet fields. One API downside to this approach was field specific prefixes like TCPWindowSize and IPAddress, to clarify which fields went with which packet header.</P>
<P>When users asked to be able to construct packets from values a significant issue became apparent. To build say a Udp packet a user needs to provide all of the fields for the Udp packet, including payload, as well as those of all of the other inherited packets, the IP packet and Ethernet packet. This makes for more complex constructors and more complex internal code as headers for derived packets have to be preserved but their data overwritten with the encapsulated packets header and data, ie. the IP packet payload is the Udp header and the Udp payload.</p>
<p>Another issue with the inherited model is that it makes things like PPPoE difficult to represent as the PPPoE packet is inserted in the hierarchy. We no longer have the straight forward Ethernet->IP->Udp model, we now have Ethernet->PPPoE->PTP->IP->Udp. It's not clear how best to fit this kind of exception case into the inerhitance model.</p>
<p>Packet.Net switched from the inheritance model of SharpPcap 2.x to one of nesting packets. All packets contain a Packet PayloadPacket property and a Byte[] PayloadData property. One or neither of these can be valid. A Tcp packet captured on Ethernet may be EthernetPacket -> IPv4 Packet -> Tcp Packet. In Packet.Net the Tcp packet could be accessed like capturedPacket.PayloadPacket.PayloadPacket but to to aid users static GetEncapsulsted() methods have been added so users can do var tcpPacket = TcpPacket.GetEncapsulated(capturedPacket).
</p>
<p>
The GetEncapsulated() methods are intelligent. They are designed to work in many different cases. UdpPacket.GetEncapsulated() will return the Udp packet of a packet that consists of EthernetPacket -> IP packet -> UdpPacket or Linux Cooked Capture -> IP -> UdpPacket or EthernetPacket -> PPPoE -> PTP -> IP -> UdpPacket. We recommend using the GetEncapsulated() methods to retrieve sub packets vs writing your own code to do so.
</p>
<p>
With Packet.Net constructing packets looks like:
<pre>
    using PacketDotNet;

    ushort tcpSourcePort = 123;
    ushort tcpDestinationPort = 321;
    var tcpPacket = new TcpPacket(tcpSourcePort, tcpDestinationPort);

    var ipSourceAddress = System.Net.IPAddress.Parse("192.168.1.1");
    var ipDestinationAddress = System.Net.IPAddress.Parse("192.168.1.2");
    var ipPacket = new IPv4Packet(ipSourceAddress, ipDestinationAddress);

    var sourceHwAddress = "90-90-90-90-90-90";
    var ethernetSourceHwAddress = System.Net.NetworkInformation.PhysicalAddress.Parse(sourceHwAddress);
    var destinationHwAddress = "80-80-80-80-80-80";
    var ethernetDestinationHwAddress = System.Net.NetworkInformation.PhysicalAddress.Parse(destinationHwAddress);
    <span class="code-comment">// NOTE: using EthernetPacketType.None to illustrate that the ethernet
    //       protocol type is updated based on the packet payload that is
    //       assigned to that particular ethernet packet</span>
    var ethernetPacket = new EthernetPacket(ethernetSourceHwAddress,
                                            ethernetDestinationHwAddress,
                                            EthernetPacketType.None);

    <span class="code-comment">// Now stitch all of the packets together</span>
    ipPacket.PayloadPacket = tcpPacket;
    ethernetPacket.PayloadPacket = ipPacket;

    <span class="code-comment">// and print out the packet to see that it looks just like we wanted it to</span>
    Console.WriteLine(ethernetPacket.ToString());
</pre>
</p>

<H2>SharpPcap tutorial: A step by step guide to using SharpPcap</H2>
<P>Examples can be found in the Examples/ directory of the source package.</p>
<P>The text of this tutorial was taken directly from WinPcap's <A href="http://www.winpcap.org/docs/docs_41b5/html/group__wpcap__tut.html" target=_blank>official tutorial </A>but is modified to show the C# use of the SharpPcap library. All examples can be downloaded together with the SharpPcap source code from the top of this page. If you are running on Windows, the WinPcap library must be installed before attempting to run any of these examples so please download and install the latest version from <A href="http://www.winpcap.org/install/default.htm" target=_blank>WinPcap's download page</A>. If running under unix/linux/mac the libpcap library must be installed using your systems software management system.</P> 
<P>The following topics are covered in this tutorial with the name of the example in parenthesis:</P> 
<OL> 
<LI><A href="#ifList">Obtaining the device list (Example 1)</A></li> 
<LI><A href="#basicCap">Opening an adapter and capturing packets (Example 3)</A></li> 
<LI><A href="#basicCapNoCallback">Capturing packets without the event  (Example 4)</A></li> 
<LI><A href="#filter">Filtering the traffic (Example 5)</A></li>
<LI><A href="#dumpTCP">Interpreting the packets (Example 6)</A></li> 
<LI><A href="#offline">Handling offline dump files (Example 8)</A></li> 
<LI><A href="#sendPackets">Sending packets (Example 9)</A></li> 
<LI><A href="#sendqueues">Send Queues (Example 10) - WinPcap only</A></li>
<LI><A href="#statistics">Gathering statistics on the network traffic (Example 11) - WinPcap only</A></LI>
<LI><A href="#QueuingPacketsForBackgroundProcessing">Queuing packets for background processing - High packet rate capture</a></li>
</OL> 


<H3 id=ifList>Obtaining the device list (Example 1 in the source package)</H3> 
<P>Typically, the first thing that a SharpPcap-based application does is get a list of attached network adapters. SharpPcap provides a class, <code>LivePcapDeviceList</code> for this purpose. The class is a singleton instance that holds a cached list of network adapters of type <code>LivePcapDevice</code>. In particular, the <CODE>Name</CODE> and <CODE>Description</CODE> properties contain the name and a human readable description, respectively, of the corresponding device. The following C# sample shows how to retrieve a list of adapters and print it on the screen, printing an error if no adapters are found:</P>

<PRE lang=cs>
<span class="code-comment">// Print SharpPcap version</span> 
string ver = SharpPcap.Version.VersionString;
Console.WriteLine(<span class="code-string">&quot;SharpPcap {0}, Example1.IfList.cs&quot;</span>, ver);

<span class="code-comment">// Retrieve the device list</span>
<span class="code-keyword">LivePcapDeviceList</span> devices = LivePcapDeviceList.Instance;

<span class="code-comment">// If no devices were found print an error</span>
<span class="code-keyword">if</span>(devices.Count &lt; 1)
{
    Console.WriteLine(<span class="code-string">&quot;No devices were found on this machine&quot;</span>);
    <span class="code-keyword">return</span>;
}
 
Console.WriteLine(<span class="code-string">&quot;\nThe following devices are available on this machine:&quot;</span>);
Console.WriteLine(<span class="code-string">&quot;----------------------------------------------------\n&quot;</span>);


<span class="code-comment">// Print out the available network devices</span> 
<span class="code-keyword">foreach</span>(LivePcapDevice dev <span class="code-keyword">in</span> devices)
    Console.WriteLine(<span class="code-string">&quot;{0}\n&quot;</span>, dev.ToString());

Console.Write(<span class="code-string">&quot;Hit 'Enter' to exit...&quot;</span>);
Console.ReadLine();
</PRE> 
<P>The output of the above application will be as something like this:</P>
<PRE lang=text>
c:\sharppcap\Examples\Example1.IfList\bin\Debug>Example1.IfList.exe
SharpPcap 3.1.0.0, Example1.IfList.cs

The following devices are available on this machine:
----------------------------------------------------

interface: Name: \Device\NPF_{D8B7C9B2-D53D-45DA-ACF0-2E2116F97314}
FriendlyName: Local Area Connection 2
Description: Intel(R) PRO/1000 MT Desktop Adapter
Addresses:
Addr:      fe80::b444:92d8:c882:8227
Netmask:
Broadaddr:

Addresses:
Addr:      10.0.2.15
Netmask:   255.255.255.0
Broadaddr: 255.255.255.255

Addresses:
Addr:      HW addr: 0800276AC792

Flags: 0



Hit 'Enter' to exit...
</PRE> 
<H3 id=basicCap>Opening an adapter and capturing packets (Example 3 in the source package)</H3> 
<P>Now that we've seen how to obtain an adapter to play with, let's start the real job, opening an adapter and capturing some traffic. In this section, we'll write a program that prints some information about each packet flowing through the adapter.</P> 
<P>The function that opens a device for capture is <CODE>Open()</CODE> which is overloaded with some arguments as follows:</P> 
<UL class=method> 
<LI><CODE>Open()</CODE> 
<LI><CODE lang=cs>Open(<span class="code-keyword">DeviceMode</span> mode)</CODE> 
<LI><CODE lang=cs>Open(<span class="code-keyword">DeviceMode</span> mode, <span class="code-keyword">int</span> read_timeout)</CODE> </LI></UL> 
<P>The above two arguments deserve some further explanation.</P> 
<P><CODE>DeviceMode</CODE> In normal mode (<code>DeviceMode.Normal</code>), a network adapter only captures packets addressed directly to it; the packets exchanged by other hosts on the network are ignored. Instead, when the adapter is in promiscuous mode (<code>DeviceMode.Promiscuous</code>) it captures all packets whether they are destined to it or not. This means that on shared media (like non-switched Ethernet), libpcap/WinPcap will be able to capture the packets of other hosts. Promiscuous mode is the default for most capture applications, so we enable it in the following example. NOTE: Promiscuous mode can be detected via network means so if you are capturing in promiscuous mode you may be able to be detected by other entities on the network. Search for "detect promiscuous" via a web search engine for more information.</P>
<P><CODE>read_timeout</CODE>: Specifies the read timeout, in milliseconds. A read on the adapter (for example, using the <CODE>GetNextPacket()</CODE> function) will always return after <CODE>read_timeout</CODE> milliseconds, even if no packets are available from the network. <CODE>read_timeout</CODE> also defines the interval between statistical reports if the adapter is in statistical mode (see the <I><A href="#statistics">Gathering statistics on the network traffic</A></I> section). Setting <CODE>read_timeout</CODE> to 0 means no timeout, a read on the adapter never returns if no packets arrive. A -1 timeout on the other side causes a read on the adapter to always return immediately.</P> 
<P>The following example shows the use of the <CODE>OnPacketArrival</CODE> event for receiving packets. We create an event handler that is being called whenever a new packet is going through the <CODE>PcapDevice</CODE>:</P>
<PRE lang=cs>
<span class="code-comment">// Extract a device from the list</span> 
PcapDevice device = devices[i];

<span class="code-comment">// Register our handler function to the</span> 
<span class="code-comment">// 'packet arrival' event</span> 
device.OnPacketArrival += 
  <span class="code-keyword">new</span> SharpPcap.PacketArrivalEventHandler(device_OnPacketArrival);
 
<span class="code-comment">// Open the device for capturing</span> 
<span class="code-keyword">int</span> readTimeoutMilliseconds = 1000; 
device.Open(DeviceMode.Promiscuous, readTimeoutMilliseconds);

Console.WriteLine(
    <span class="code-string">&quot;-- Listening on {0}, hit 'Enter' to stop...&quot;</span>,
    device.Description);

<span class="code-comment">// Start the capturing process</span> 
device.StartCapture();

<span class="code-comment">// Wait for 'Enter' from the user.</span> 
Console.ReadLine();
 
<span class="code-comment">// Stop the capturing process</span> 
device.StopCapture();

<span class="code-comment">// Close the pcap device</span>
device.Close();</PRE> 
<P>And here is our packet handler implementation:</P>
<PRE lang=cs>
<span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span> </span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> Prints the time and length of each received packet</span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">/</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span> </span> 
<span class="code-keyword">private</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> device_OnPacketArrival(<span class="code-keyword">object</span> sender, CaptureEventArgs packet)
{
    DateTime time = packet.Timeval.Date;
    <span class="code-keyword">int</span> len = packet.Data.Length;
    Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string">{0}:{1}:{2},{3} Len={4}&quot;</span>, 
        time.Hour, time.Minute, time.Second, time.Millisecond, len);
}</PRE> 
<P>Once the adapter is opened, the capture can be started with the <CODE>StartCapture()</CODE> or <CODE lang=cs>Capture(<span class="code-keyword">int</span> packetCount)</CODE> functions. These two functions are very similar, the difference is that <CODE>StartCapture()</CODE> is a non-blocking function that starts the capturing process on a new thread, while <CODE lang=cs>Capture(<span class="code-keyword">int</span> packetCount)</CODE> blocks until <CODE>packetCount</CODE> packets have been captured. When using <CODE>StartCapture()</CODE> we should later call <CODE>StopCapture()</CODE> to terminate the capture process. To capture indefinitely call the <CODE lang=cs>Capture()</CODE> method.</P> 
<P>Both of these functions require that an event handler for processing packets registered prior to calling them. This event handler is invoked by <CODE>PcapDevice</CODE> for every new packet coming from the network and receives the sender object that invoked this handler (i.e. the <CODE>PcapDevice</CODE> object) and the actual received <CODE>Packet</CODE>, including all the protocol headers. Note that the frame CRC is normally not present in the packet, because it is removed by the network adapter after the frame validation. Note also that most adapters discard packets with wrong CRCs, so WinPcap (and therefore SharpPcap) is normally not able to capture them.</P> 
<P>The <CODE>Packet</CODE> class represents a generic packet captured from the network. Each such packet has a <CODE>PcapHeader</CODE> property containing some info (e.g. the timestamp of the capture and the length of the packet) about the captured packet. The above example extracts the timestamp and the length from every <CODE>Packet</CODE> object and prints them on the screen.</P> 
<P>Please note that the handler code is called by the <CODE>PcapDevice</CODE>; therefore the user application does not have direct control over it. Another approach is to use the <CODE>GetNextPacket()</CODE> function, which is presented in the next section.</P>

<H3 id=basicCapNoCallback>Capturing packets without the event handler (Example 4 in the source package)</H3>
<P>The example program in this section behaves exactly like the previous sample, but it uses <CODE>PcapDevice.GetNextPacket()</CODE> method instead of registering an event handler. The <CODE>OnPacketArrival</CODE> event is a good practice and could be a good choice in some situations, such as when capturing from several devices at once. However, handling a callback is sometimes not practical - it often makes the program more complex especially in situations with multithreaded applications. In these cases, <CODE>GetNextPacket()</CODE> retrieves a packet with a direct call - using <CODE>GetNextPacket()</CODE>, packets are received only when the programmer wants them. In the following program, we re-use the event handler code of the previous example and move it into a loop in the main function right after the call to <CODE>GetNextPacket()</CODE>.</P> 
<P><B>Note</B>: The following example will exit if the timeout of 1000 ms expires with no packets on the network:</P>
<PRE lang=cs>
<span class="code-comment">// Extract a device from the list</span> 
PcapDevice device = devices[i];

<span class="code-comment">// Open the device for capturing</span>
<span class="code-keyword">int</span> readTimeoutMilliseconds = 1000;
device.Open(DeviceMode.Promiscuous, readTimeoutMilliseconds);

Console.WriteLine();
Console.WriteLine(<span class="code-string">&quot;-- Listening on {0}...&quot;</span>,
    device.Description);
 
Packet packet = <span class="code-keyword">null</span>;
 
<span class="code-comment">// Keep capture packets using GetNextPacket()</span> 
<span class="code-keyword">while</span>( (packet=device.GetNextPacket()) != <span class="code-keyword">null</span> )
{
    <span class="code-comment">// Prints the time and length of each received packet</span> 
    DateTime time = packet.PcapHeader.Date;
    <span class="code-keyword">int</span> len = packet.PcapHeader.PacketLength;
    Console.WriteLine(<span class="code-string">&quot;{0}:{1}:{2},{3} Len={4}&quot;</span>, 
              time.Hour, time.Minute, time.Second, 
              time.Millisecond, len);
}

<span class="code-comment">// Close the pcap device</span> 
device.Close();
Console.WriteLine(<span class="code-string">&quot; -- Capture stopped, device closed.&quot;</span>);</PRE> 
<H3 id=filter>Filtering the traffic (Example 5 in the source package)</H3> 
<P>One of the most powerful features offered by libpcap and WinPcap is the filtering engine. It provides a very efficient way to receive subsets of the network traffic. WinPcap and libpcap have an integrated compiler that takes a string containing a high-level Boolean (filter) expression and produces a low-level byte code that can be interpreted by the filter engine of the packet capture driver. The syntax (also known as the <I>tcpdump syntax</I>) of the boolean expression is widely used in many applications other than WinPcap and libpcap. You can find its spec in WinPcap's <A href="http://www.winpcap.org/docs/docs_40_2/html/group__language.html" target=_blank>documentation page</A> or if you are running linux via 'man pcap-filter'.</P> 
<P>The function <CODE>SetFilter()</CODE> associates a filter with a capture adapter. Once <CODE>SetFilter()</CODE> is called, the associated filter will be applied to all the packets coming from the network, and all the conformant packets (i.e., packets for which the boolean expression evaluates to true) will be actually copied to the application. The following code shows how to compile and set a filter.</P> 
<P>Note that libpcap/winpcap's expression compiler requires that the netmask of the <CODE>PcapDevice</CODE> to be passed together with the filter, because some filters created by the compiler require it. However SharpPcap takes care of it for us by automatically extracting the netmask from the adapter.</P> 
<P>The filter expression we use in the following snippet is "ip and tcp", which means to "keep only the packets that are both IPv4 and TCP and deliver them to the application":</P>
<PRE lang=cs>
<span class="code-comment">// Open the device for capturing</span> 
<span class="code-keyword">int</span> readTimeoutMilliseconds = 1000;
device.Open(DeviceMode.Promiscuous, readTimeoutMilliseconds);
 
<span class="code-comment">// tcpdump filter to capture only TCP/IP packets</span> 
<span class="code-keyword">string</span> filter = <span class="code-string">&quot;ip and tcp&quot;</span>;
device.SetFilter( filter );
 
Console.WriteLine();
Console.WriteLine
  (<span class="code-string">&quot;-- The following tcpdump filter will be applied: \&quot;{0}\&quot;&quot;</span>, 
  filter);
Console.WriteLine
  (<span class="code-string">&quot;-- Listening on {0}, hit 'Enter' to stop...&quot;</span>,
  device.Description);
 
<span class="code-comment">// Start capturing packets indefinitely</span>
device.Capture();
 
<span class="code-comment">// Close the pcap device</span> 
<span class="code-comment">// (Note: this line will never be called since</span> 
<span class="code-comment">// we're capturing indefinitely</span> 
device.Close();</PRE> 

<H3 id=dumpTCP>Interpreting the packets (Example 6 in the source package)</H3> 
<P>Now that we are able to capture and filter network traffic, we want to put our knowledge to work with a simple "real world" application. In this lesson, we will take the code from the previous sections and use these pieces to build a more useful program. The main purpose of the current program is to show how the protocol headers of a captured packet can be parsed and interpreted. The resulting application, called DumpTCP, prints a summary of the TCP traffic on our network. I have chosen to parse and display the TCP protocol (rather than the UDP example posted in the original tutorial) because it is a bit more interesting than UDP and with SharpPcap it doesn't require too much parsing coding.</P><PRE lang=cs><span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span></span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> Prints the time, length, src ip,</span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> src port, dst ip and dst port</span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> for each TCP/IP packet received on the network</span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">/</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span></span> 
<span class="code-keyword">private</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> device_OnPacketArrival(
                       <span class="code-keyword">object</span> sender, CaptureEventArgs e)
{
    var tcp = TcpPacket.GetEncapsulated(e.Packet);
    <span class="code-keyword">if</span>(tcp != null)
    {                
        DateTime time = e.Packet.Timeval.Date;
        <span class="code-keyword">int</span> len = e.Packet.Data.Length;
 
        <span class="code-keyword">string</span> srcIp = tcp.SourceAddress;
        <span class="code-keyword">string</span> dstIp = tcp.DestinationAddress;
 
        Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string">{0}:{1}:{2},
            {3} Len={4}", 
            time.Hour, time.Minute, time.Second, 
            time.Millisecond, len);
        Console.WriteLine(e.Packet.ToString());
    }
}</PRE> 
<P>If you take a look at the <A href="http://www.winpcap.org/docs/docs_41b5/html/group__wpcap__tut6.html" target=_blank>UDP example</A> of the original WinPcap tutorial you will see how complex it is to parse the packets (although UDP is a bit simpler to parse than TCP in our example) directly from the raw data bytes provided by the WinPcap library. Luckily for us, SharpPcap provides some useful packet analyzing classes for some common protocols (e.g. TCP, UDP, ICMP and others). These analyzing classes were initially a direct C# translation from <A href="http://jpcap.sourceforge.net/" target=_blank>JPcap</A>, a Java wrapper for libpcap/WinPcap similar to SharpPcap, but significant changes have been made to make them fit better into .NET, including the rewrite to <a href="http://packetnet.sf.net"><b>Packet.Net</b></a>. All of the packet parsing and generation code can be found in the <code>PacketDotNet</code> namespace in the PacketDotNet assembly.
<P>As you can see, in our packet handler we first attempt to extract the Tcp packet encapsulated in the packet that was captured on the line. If one was found, and it should be since our filter selects only tcp packets, we can then access its properties. If we also wanted to see the IP packet properties these could be accessed via <code>var ip = IpPacket.GetEncapsulated(e.Packet);</code></P> 
<PRE lang=text>
Available devices:
------------------
 
1) Intel(R) PRO/1000 MT Mobile Connection 
   (Microsoft's Packet Scheduler)
 
-- Please choose a device to capture: 1
 
-- Listening on Intel(R) PRO/1000 MT Mobile Connection 
-- (Microsoft's Packet Scheduler)...
1:18:17,675 Len=123 66.102.7.147:80 -&gt; 10.21.98.21:43501
1:18:17,675 Len=80 10.21.98.21:43501 -&gt; 66.102.7.147:80
1:18:17,919 Len=54 66.102.7.147:80 -&gt; 10.21.98.21:43501</PRE> 
<P>Each of the final three lines represents a different packet.</P> 
<H3 id=offline>Handling offline dump files (Example 8 in the source package)</H3> 
<P>In this section, we are going to learn how to handle packet capture to a file (dump to file). Libpcap/WinPcap offer built-in functions for saving network traffic to a file and to read the content of dumps - this section will teach you how to accomplish this with SharpPcap. The format for dump files is the libpcap one. This format contains the data of the captured packets in binary form and is a standard widely used by many network tools including wireshark, windump, tcpdump and snort. Therefore, any dump file we create using SharpPcap can be opened with any of the above tools and others and files created by these tools can be opened by SharpPcap.</P> 
<H4>Saving packets to a dump file</H4> 
<P>First of all, let's see how to write packets in libpcap file format. The following example captures the packets from the selected interface and saves them on a file whose name is provided by the user:</P><PRE lang=cs>Console.Write(<span class="code-string">&quot;</span><span class="code-string">-- Please enter the output file name: &quot;</span>);
<span class="code-keyword">string</span> capFile = Console.ReadLine();
 
PcapDevice device = LivePcapDeviceList.Instance[i];
 
<span class="code-comment">// Register our handler function to the 'packet arrival' event</span> 
device.OnPacketArrival += 
  <span class="code-keyword">new</span> SharpPcap.PacketArrivalEventHandler( device_OnPacketArrival );
 
<span class="code-comment">// Open the device for capturing</span>
<span class="code-keyword">int</span> readTimeoutMilliseconds = 1000; 
device.Open(DeviceMode.Promiscuous, readTimeoutMilliseconds);

<span class="code-comment">// Open or create a capture output file</span> 
device.DumpOpen( capFile );
 
Console.WriteLine();
Console.WriteLine
    (<span class="code-string">&quot;-- Listening on {0}, hit 'Ctrl-C' to exit...&quot;</span>,
    device.Description);

<span class="code-comment">// Start capturing indefinitely</span> 
device.Capture();
 
<span class="code-comment">// Close the pcap device</span> 
<span class="code-comment">// (Note: this line will never be called since</span>
<span class="code-comment">// we're capturing forever</span>
device.Close();
</PRE> 
<P>And here is the packet handler that will dump each received packet to the file:</P><PRE lang=cs><span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span></span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> Dumps each received packet to a pcap file</span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">/</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span></span> 
<span class="code-keyword">private</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> device_OnPacketArrival(
                        <span class="code-keyword">object</span> sender, CaptureEventArgs packet)
{                        
    PcapDevice device = (PcapDevice)sender;
    <span class="code-comment">// if device has a dump file opened</span> 
    <span class="code-keyword">if</span>( device.DumpOpened )
    {
        <span class="code-comment">// dump the packet to the file</span> 
        device.Dump( packet );
        Console.WriteLine(<span class="code-string">&quot;Packet dumped to file.&quot;</span>);
    }
}</PRE> 
<P>As you can see, the structure of the program is very similar to the ones we have seen in the previous sections. The differences are:</P> 
<UL> 
<LI>The call to <CODE>device.DumpOpen( capFile )</CODE> is issued once the interface is opened. This call opens a dump file and associates it with the interface. 
<LI>The packets are written to this file with the <CODE>device.Dump( packet )</CODE> call in the packet handler. Note the use of the sender object parameter passed to the packet handler callback which is casted to a <CODE>PcapDevice</CODE>. </LI></UL> 
<br/>
<H4>Reading packets from a dump file</H4> 
<P>Now that we have a dump file available, we can try to read its content. The following code opens a WinPcap/libpcap dump file and displays every packet contained in the file. The <CODE>SharpPcap.OfflinePcapDevice( capFile )</CODE> class is a <CODE>PcapDevice</CODE> object which represents the offline capture file that we read, then the usual <CODE>OnPacketArrival</CODE> event is used to sequence through the packets. As you can see, reading packets from an offline capture is nearly identical to receiving them from a physical interface:</P>

<PRE lang=cs>
Console.Write(<span class="code-string">&quot;-- Please enter an input capture file name: &quot;</span>);
<span class="code-keyword">string</span> capFile = Console.ReadLine();
 
PcapDevice device;
 
<span class="code-keyword">try</span> 
{
    <span class="code-comment">// Get an offline file pcap device</span> 
    device = new OfflinePcapDevice( capFile );
    <span class="code-comment">// Open the device for capturing</span> 
    device.Open();
} 
<span class="code-keyword">catch</span>(Exception e)
{
    Console.WriteLine(e.Message);
    <span class="code-keyword">return</span>;
}
 
<span class="code-comment">// Register our handler function to the 'packet arrival' event</span> 
device.OnPacketArrival += 
  <span class="code-keyword">new</span> SharpPcap.PacketArrivalEventHandler(device_OnPacketArrival);
 
Console.WriteLine();
Console.WriteLine
    (<span class="code-string">&quot;-- Capturing from '{0}', hit 'Ctrl-C' to exit...&quot;</span>,
    capFile);

<span class="code-comment">// Start capturing an indefinite number of packets</span> 
device.Capture();

<span class="code-comment">// Close the pcap device</span> 
device.Close();
Console.WriteLine(<span class="code-string">&quot;-- End of file reached.&quot;</span>);
</PRE>

<H3 id=sendPackets>Sending packets (Example 9 in the source package)</H3> 
<P>The simplest way to send a packet is shown in the following code snippet. After opening an adapter, <CODE>SendPacket</CODE> is called to send a hand-crafted packet. <CODE>SendPacket</CODE> takes as argument a byte array or a <CODE>Packet</CODE> object containing the data to be sent. Notice that the buffer is sent to the network as it was received. This means that the application has to create the correct protocol headers in order to send something meaningful:</P>
<PRE lang=cs>
<span class="code-comment">// Open the device</span> 
device.Open();
 
<span class="code-comment">// Generate a random packet</span> 
<span class="code-keyword">byte</span>[] bytes = GetRandomPacket();
 
<span class="code-keyword">try</span> 
{
    <span class="code-comment">// Send the packet out the network device</span> 
    device.SendPacket( bytes );
    Console.WriteLine(<span class="code-string">&quot;-- Packet sent successfuly.&quot;</span>);
}
<span class="code-keyword">catch</span>(Exception e)
{
    <span class="code-keyword">Console.WriteLine</span>(<span class="code-string">&quot;-- &quot;</span>+ e.Message );
}
 
<span class="code-comment">// Close the pcap device</span> 
device.Close();
Console.WriteLine(<span class="code-string">&quot;-- Device closed.&quot;</span>);</PRE> 


<H3 id=sendqueues>Send queues - WinPcap specific extension (Example 10 in the source package)</H3> 
<P>While <CODE>SendPacket</CODE> offers a simple and immediate way to send a single packet, <B>send queues</B> provide an advanced, powerful and optimized mechanism to send a collection of packets. A send queue is a container for a variable number of packets that will be sent to the network. It has a size, that represents the maximum amount of bytes it can store.</P>
<p> Because SendQueue functionality is WinPcap specific the authors of SharpPcap recommend benchmarking your particular usage of sending packets to determine if the loss of cross platform support is worth the added efficiency of using send queues. The old adage, "avoid premature optimization" should be carefullyl considered.</p>
<P>SharpPcap represents a send queue using the <CODE>SendQueue</CODE> class which is constructed by specifying the size of the new send queue.</P> 
<P>Once the send queue is created, <CODE>SendQueue.Add()</CODE> can be called to add a packet to the send queue. This function takes a <CODE>PcapHeader</CODE> with the packet's timestamp and length and a buffer or a <CODE>Packet</CODE> object holding the data of the packet. These parameters are the same as those received by the <CODE>OnPacketArrival</CODE> event, therefore queuing a packet that was just captured or a read from a file is a matter of passing these parameters to <CODE>SendQueue.Add()</CODE>.</P> 
<P>To transmit a send queue, SharpPcap provides the <CODE lang=cs>PcapDevice.SendQueue(SendQueue q, <span class="code-keyword">SendQueueTransmitModes</span> transmitMode)</CODE> function. Note the second parameter: if <CODE lang=cs><span class="code-keyword">SendQueueTransmitModes.Synchronized</span></CODE>, the send will be <I>synchronized</I>, i.e. the relative timestamps of the packets will be respected. This operation requires a remarkable amount of CPU, because the synchronization takes place in the kernel driver using "busy wait" loops. Although this operation is quite CPU intensive, it often results in very high precision packet transmissions (often around few microseconds or less).</P> 
<P>Note that transmitting a send queue with <CODE>PcapDevice.SendQueue()</CODE> is more efficient than performing a series of <CODE>PcapDevice.SendPacket()</CODE>, since the send queue buffered at kernel level drastically decreases the number of context switches.</P> 
<P>When a queue is no longer needed, it can be deleted with <CODE>SendQueue.Dispose()</CODE> that frees all the buffers associated with the send queue.</P> 
<P>The next program shows how to use send queues. It opens a capture file by creating a <CODE>OfflinePcapDevice()</CODE>, then it stores the packets from the file to a properly allocated send queue. At his point it transmits the queue synchronized.</P> 
<P>Note that the link-layer of the dumpfile is compared with one of the interface that will send the packets using the <CODE>PcapDevice.DataLink</CODE> property, and a warning is printed if they are different - it is important that the capture-file link-layer be the same as the adapter's link layer for otherwise the transmission is pointless:</P>
<PRE lang=cs>
PcapDevice device;
 
<span class="code-keyword">try</span> 
{
    <span class="code-comment">// Get an offline file pcap device</span> 
    device = <span class="code-keyword">new</span> OfflinePcapDevice( capFile );
    <span class="code-comment">// Open the device for capturing</span> 
    device.Open();
} 
<span class="code-keyword">catch</span>(Exception e)
{
    Console.WriteLine(e.Message);
    <span class="code-keyword">return</span>;
}
 
Console.Write(<span class="code-string">&quot;Queueing packets...&quot;</span>);
 
<span class="code-comment">// Allocate a new send queue</span> 
SendQueue squeue = <span class="code-keyword">new</span> SendQueue
    ( (<span class="code-keyword">int</span>)((OfflinePcapDevice)device).PcapFileSize );
Packet packet;
 
<span class="code-keyword">try</span> 
{
  <span class="code-comment">// Go through all packets in the file and add to the queue</span> 
  <span class="code-keyword">while</span>( (packet=device.GetNextPacket()) != <span class="code-keyword">null</span> )
  {
     <span class="code-keyword">if</span>( !squeue.Add( packet ) )
     {
        Console.WriteLine(<span class="code-string">&quot;Warning: packet buffer too small, &quot;</span>+
                            <span class="code-string">&quot;not all the packets will be sent.&quot;</span>);
        <span class="code-keyword">break</span>;
     }
  }
}
<span class="code-keyword">catch</span>(Exception e)
{
    Console.WriteLine(e.Message);
    <span class="code-keyword">return</span>;
}

Console.WriteLine(<span class="code-string">&quot;OK&quot;</span>);
 
Console.WriteLine();
Console.WriteLine(<span class="code-string">&quot;The following devices are available on this machine:&quot;</span>);
Console.WriteLine(<span class="code-string">&quot;----------------------------------------------------&quot;</span>);
Console.WriteLine();
 
<span class="code-keyword">int</span> i=0;
 
var devices = LivePcapDeviceList.Instance;

<span class="code-comment">// Print out all available devices</span> 
<span class="code-keyword">foreach</span>(PcapDevice dev <span class="code-keyword">in</span> devices)
{
    Console.WriteLine(<span class="code-string">&quot;{0}) {1}&quot;</span>, i, dev.Description);
    i++;
}

Console.WriteLine();
Console.Write(<span class="code-string">&quot;-- Please choose a device to transmit on: &quot;</span>);
i = <span class="code-keyword">int</span>.Parse( Console.ReadLine() );
devices[i].Open();
<span class="code-keyword">string</span> resp;
 
<span class="code-keyword">if</span>(devices[i].PcapDataLink != device.PcapDataLink)
{
    Console.Write(<span class="code-string">&quot;Warning: the datalink of the capture&quot;</span>+
           <span class="code-string">&quot;differs from the one of the selected interface, 
           continue? [YES|no]&quot;</span>);
    resp = Console.ReadLine().ToLower();
 
    <span class="code-keyword">if</span>((resp!=<span class="code-string">&quot;</span><span class="code-string">&quot;</span>)&amp;&amp;( !resp.StartsWith(<span class="code-string">&quot;</span><span class="code-string">y&quot;</span>)))
    {
        Console.WriteLine(<span class="code-string">&quot;Cancelled by user!&quot;</span>);
        devices[i].Close();
        <span class="code-keyword">return</span>;
    }
}

<span class="code-comment">// Close the offline device</span>
device.Close();

<span class="code-comment">// find the network device for sending the packets we read</span>
device = devices[i];

Console.Write(<span class="code-string">&quot;This will transmit all queued packets through&quot;</span>+
                            <span class="code-string">&quot;this device, continue? [YES|no]&quot;</span>);
resp = Console.ReadLine().ToLower();
 
<span class="code-keyword">if</span>((resp!=<span class="code-string">&quot;&quot;</span>)&amp;&amp;( !resp.StartsWith(<span class="code-string">&quot;y&quot;</span>)))
{
    Console.WriteLine(<span class="code-string">&quot;Cancelled by user!&quot;</span>);
    <span class="code-keyword">return</span>;
}

<span class="code-keyword">try</span> 
{
    Console.Write(<span class="code-string">&quot;Sending packets...&quot;</span>);
    <span class="code-keyword">int</span> sent = device.SendQueue( squeue, <span class="code-keyword">SendQueueTransmitModes.Synchronized</span> );
    Console.WriteLine(<span class="code-string">&quot;Done!&quot;</span>);
    <span class="code-keyword">if</span>( sent &lt; squeue.CurrentLength )
    {
       Console.WriteLine(<span class="code-string">&quot;An error occurred sending the packets: {0}. &quot;</span>+
               <span class="code-string">&quot;Only {1} bytes were sent\n&quot;</span>, device.LastError, sent);
    }
}
<span class="code-keyword">catch</span>(Exception e)
{
    Console.WriteLine(<span class="code-string">&quot;Error: &quot;</span>+e.Message );
}
<span class="code-comment">// Free the queue</span> 
squeue.Dispose();
Console.WriteLine(<span class="code-string">&quot;-- Queue is disposed.&quot;</span>);
<span class="code-comment">// Close the pcap device</span>
device.Close();
Console.WriteLine(<span class="code-string">&quot;-- Device closed.&quot;</span>);</PRE> 


<H3 id=statistics>Gathering statistics on the network traffic - WinPcap only (Example 11 in the source package)</H3> 
<P>Adapter statistics are available by calling the PcapDevice.Statistics() method but WinPcap has a statistics extension that provides statistics callbacks. WinPcap's statistical engine makes use of the kernel-level packet filter to efficiently classify the incoming packet. You can take a look at the <A href="http://www.winpcap.org/docs/docs_41b5/html/group__NPF.html" target=_blank>NPF driver internals manual</A> if you want to learn more about the details.</P> 
<P>In order to use this feature, the programmer must open an adapter and put it in <I>statistical</I> mode. This can be done by setting the <CODE>PcapDevice.Mode</CODE> property. In particular, the <code>PcapDevice.Mode</code> property should be set to <CODE>CaptureMode.Statistics</CODE>.</P> 
<P>With the statistical mode, making an application that monitors the TCP traffic load is a matter of few lines of code. The following sample shows how to do this:</P>
<PRE lang=cs>
<span class="code-comment">// Register our handler function to the </span> 
<span class="code-comment">// 'winpcap statistics' event</span> 
device.OnPcapStatistics += 
  <span class="code-keyword">new</span> SharpPcap.StatisticsEventHandler( 
                         device_OnPcapStatistics );

<span class="code-comment">// Open the device for capturing</span>
<span class="code-keyword">int</span> readTimeoutMilliseconds = 1000;
device.Open(DeviceMode.Promiscuous, readTimeoutMilliseconds);

<span class="code-comment">// Handle TCP packets only</span> 
device.SetFilter( <span class="code-string">&quot;tcp&quot;</span> );

<span class="code-comment">// Set device to statistics mode</span> 
device.PcapMode = CaptureMode.Statistics;

Console.WriteLine();
Console.WriteLine(<span class="code-string">&quot;-- Gathering statistics on \&quot;{0}\&quot;, 
      hit 'Enter' to stop...&quot;</span>, device.Description);

<span class="code-comment">// Start the capturing process</span> 
device.StartCapture();

<span class="code-comment">// Wait for 'Enter' from the user.</span> 
Console.ReadLine();
 
<span class="code-comment">// Stop the capturing process</span> 
device.StopCapture();
 
<span class="code-comment">// Close the pcap device</span> 
device.Close();
Console.WriteLine(<span class="code-string">&quot;Capture stopped, 
                     device closed.&quot;</span>);
</PRE> 
<P>And our event handler will print the statistics:</P>
<PRE lang=cs>
<span class="code-keyword">static</span> <span class="code-keyword">int</span> oldSec = 0;
<span class="code-keyword">static</span> <span class="code-keyword">int</span> oldUsec = 0;

<span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span></span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> Gets a pcap stat object and calculate bps and pps</span> 
<span class="code-SummaryComment">///</span><span class="code-comment"> <span class="code-SummaryComment">&lt;</span><span class="code-SummaryComment">/</span><span class="code-SummaryComment">SUMMARY</span><span class="code-SummaryComment">&gt;</span></span> 
<span class="code-keyword">private</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> device_OnPcapStatistics(
             <span class="code-keyword">object</span> sender, StatisticsModeEventArgs statistics)
{
    <span class="code-comment">// Calculate the delay in microseconds</span> 
    <span class="code-comment">// from the last sample.</span> 
    <span class="code-comment">// This value is obtained from the timestamp</span> 
    <span class="code-comment">// that's associated with the sample.</span> 
    <span class="code-keyword">int</span> delay = (statistics.Seconds - oldSec) * 
              <span class="code-digit">1000000</span> - oldUsec + statistics.MicroSeconds;
    <span class="code-comment">/*</span><span class="code-comment"> Get the number of Bits per second */</span> 
    <span class="code-keyword">long</span> bps =  
        ( statistics.RecievedBytes * <span class="code-digit">8</span> * <span class="code-digit">1000000</span>) / delay;
    <span class="code-comment">/*</span><span class="code-comment">                                  ^        ^
                                     |        |
                                     |        |
                                     |        |
            converts bytes in bits      -----         |
          delay is expressed in microseconds ---------
    */</span> 
 
    <span class="code-comment">// Get the number of Packets per second</span> 
    <span class="code-keyword">long</span> pps=
        (statistics.RecievedPackets * <span class="code-digit">1000000</span>) / delay;
 
    <span class="code-comment">// Convert the timestamp to readable format</span> 
    <span class="code-keyword">string</span> ts = statistics.Date.ToLongTimeString();
 
    <span class="code-comment">// Print Statistics</span> 
    Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string">{0}: bps={1}, pps={2}&quot;</span>, 
                                     ts, bps, pps); 
 
    <span class="code-comment">// store current timestamp</span> 
    oldSec = statistics.Seconds;
    oldUsec = statistics.MicroSeconds;
}</PRE>
<P>Note that this example is by far more efficient than a program that captures the packets in the traditional way and calculates statistics at the user-level. Statistical mode requires minimum amount of data copies and context switches and therefore the CPU is optimized. Moreover, a very small amount of memory is required. The downside is that if your application uses statistical mode it will only work with WinPcap on Windows.</P>

<H3 id=QueuingPacketsForBackgroundProcessing>Queuing packets for background processing - High packet rate capture (Example QueuingPacketsForBackgroundProcessing in the source package)</H3> 
<P>Packet rates can exceed the rate at which they can be processed by the callback routines. This can occur if the packet processing code is time intensive, such as writing to disk, or if the packet processing code is performing advanced logic. Sometimes it is possible to reduce packet rates by applying bnf filters but in other cases these filters can be complex.</p>
<p>If packet rates only exceed the rate of processing for short periods of time it is possible to simply defer packet processing until periods of less activity. One technique for this is to queue the packets and process them in a background thread as shown in this example.</P>
<pre lang=cs>
<span class="code-keyword">using</span> System;
<span class="code-keyword">using</span> System.Collections.Generic;
<span class="code-keyword">using</span> SharpPcap;

<span class="code-keyword">namespace</span> QueuingPacketsForBackgroundProcessing
{
    <span class="code-comment">/// <summary>
    /// Basic capture example showing simple queueing for background processing
    /// </summary></span>
    <span class="code-keyword">public class</span> MainClass
    {
        <span class="code-comment">/// &lt;summary&gt;
        /// When true the background thread will terminate
        /// &lt;/summary&gt;
        /// &lt;param name="args"&gt;
        /// A &lt;see cref="System.String"/&gt;
        /// &lt;/param&gt;</span>
        <span class="code-keyword">private static bool</span> BackgroundThreadStop = false;

        <span class="code-comment">/// &lt;summary&gt;
        /// Object that is used to prevent two threads from accessing
        /// PacketQueue at the same time
        /// &lt;/summary&gt;
        /// &lt;param name="args"&gt;
        /// A &lt;see cref="System.String"/&gt;
        /// &lt;/param&gt;</span>
        <span class="code-keyword">private static object</span> QueueLock = new object();

        <span class="code-comment">/// &lt;summary&gt;
        /// The queue that the callback thread puts packets in. Accessed by
        /// the background thread when QueueLock is held
        /// &lt;/summary&gt;</span>
        <span class="code-keyword">private static</span> List<PacketDotNet.RawPacket> PacketQueue = new List<PacketDotNet.RawPacket>();

        <span class="code-comment">/// &lt;summary&gt;
        /// The last time PcapDevice.Statistics() was called on the active device.
        /// Allow periodic display of device statistics
        /// &lt;/summary&gt;
        /// &lt;param name="args"&gt;
        /// A &lt;see cref="System.String"/&gt;
        /// &lt;/param&gt;</span>
        <span class="code-keyword">private static</span> DateTime LastStatisticsOutput = DateTime.Now;

        <span class="code-comment">/// &lt;summary&gt;
        /// Interval between PcapDevice.Statistics() output
        /// &lt;/summary&gt;
        /// &lt;param name="args"&gt;
        /// A &lt;see cref="System.String"/&gt;
        /// &lt;/param&gt;</span>
        <span class="code-keyword">private static</span> TimeSpan LastStatisticsInterval = new TimeSpan(0, 0, 2);

        <span class="code-comment">/// <summary>
        /// Basic capture example
        /// </summary></span>
        <span class="code-keyword">public static void</span> Main(string[] args)
        {
            <span class="code-comment">// Print SharpPcap version</span>
            string ver = SharpPcap.Version.VersionString;
            Console.WriteLine("SharpPcap {0}", ver);

            <span class="code-comment">// If no device exists, print error</span>
            if(LivePcapDeviceList.Instance.Count < 1)
            {
                Console.WriteLine("No device found on this machine");
                <span class="code-keyword">return</span>;
            }

            Console.WriteLine();
            Console.WriteLine("The following devices are available on this machine:");
            Console.WriteLine("----------------------------------------------------");
            Console.WriteLine();

            int i=0;

            <span class="code-comment">// Print out all devices</span>
            foreach(LivePcapDevice dev in LivePcapDeviceList.Instance)
            {
                Console.WriteLine("{0}) {1} {2}", i, dev.Name, dev.Description);
                i++;
            }

            Console.WriteLine();
            Console.Write("-- Please choose a device to capture: ");
            i = int.Parse( Console.ReadLine() );

            <span class="code-comment">// start the background thread</span>
            var backgroundThread = new System.Threading.Thread(BackgroundThread);
            backgroundThread.Start();

            LivePcapDevice device = LivePcapDeviceList.Instance[i];

            <span class="code-comment">// Register our handler function to the 'packet arrival' event</span>
            device.OnPacketArrival += 
                new PacketArrivalEventHandler( device_OnPacketArrival );

            <span class="code-comment">// Open the device for capturing</span>
            device.Open();

            Console.WriteLine();
            Console.WriteLine("-- Listening on {0}, hit 'Enter' to stop...",
                device.Description);

            <span class="code-comment">// Start the capturing process</span>
            device.StartCapture();

            <span class="code-comment">// Wait for 'Enter' from the user. We pause here until being asked to
            // be terminated</span>
            Console.ReadLine();

            <span class="code-comment">// Stop the capturing process</span>
            device.StopCapture();

            Console.WriteLine("-- Capture stopped.");

            <span class="code-comment">// ask the background thread to shut down</span>
            BackgroundThreadStop = true;

            <span class="code-comment">// wait for the background thread to terminate</span>
            backgroundThread.Join();

            <span class="code-comment">// Print out the device statistics</span>
            Console.WriteLine(device.Statistics().ToString());

            <span class="code-comment">// Close the pcap device</span>
            device.Close();
        }

<span class="code-comment">
        /// <summary>
        /// Prints the time and length of each received packet
        /// </summary></span>
        <span class="code-keyword">private static void</span> device_OnPacketArrival(object sender, CaptureEventArgs e)
        {
            <span class=code-comment">// print out periodic statistics about this device</span>
            var Now = DateTime.Now; <span class="code-comment">// cache 'DateTime.Now' for minor reduction in cpu overhead</span>
            var interval = Now - LastStatisticsOutput;
            if(interval > LastStatisticsInterval)
            {
                Console.WriteLine("device_OnPacketArrival: " + ((LivePcapDevice)e.Device).Statistics());
                LastStatisticsOutput = Now;
            }

<span class="code-comment">
            // lock QueueLock to prevent multiple threads accessing PacketQueue at
            // the same time</span>
            lock(QueueLock)
            {
                PacketQueue.Add(e.Packet);
            }
        }

<span class="code-comment">
        /// <summary>
        /// Checks for queued packets. If any exist it locks the QueueLock, saves a
        /// reference of the current queue for itself, puts a new queue back into
        /// place into PacketQueue and unlocks QueueLock. This is a minimal amount of
        /// work done while the queue is locked.
        ///
        /// The background thread can then process queue that it saved without holding
        /// the queue lock.
        /// </summary></span>
        <span class="code-keyword">private static void</span> BackgroundThread()
        {
            while(!BackgroundThreadStop)
            {
                bool shouldSleep = true;

                lock(QueueLock)
                {
                    if(PacketQueue.Count != 0)
                    {
                        shouldSleep = false;
                    }
                }

                if(shouldSleep)
                {
                    System.Threading.Thread.Sleep(250);
                } else <span class="code-comment">// should process the queue</span>
                {
                    List<PacketDotNet.RawPacket> ourQueue;
                    lock(QueueLock)
                    {
                        // swap queues, giving the capture callback a new one
                        ourQueue = PacketQueue;
                        PacketQueue = new List<PacketDotNet.RawPacket>();
                    }

                    Console.WriteLine("BackgroundThread: ourQueue.Count is {0}", ourQueue.Count);

                    foreach(var packet in ourQueue)
                    {
                        var time = packet.Timeval.Date;
                        var len = packet.Data.Length;
                        Console.WriteLine("BackgroundThread: {0}:{1}:{2},{3} Len={4}", 
                            time.Hour, time.Minute, time.Second, time.Millisecond, len);
                    }

<span class="code-comment">
                    // Here is where we can process our packets freely without
                    // holding off packet capture.
                    //
                    // NOTE: If the incoming packet rate is greater than
                    //       the packet processing rate these queues will grow
                    //       to enormous sizes. Packets should be dropped in these
                    //       cases
</span>
                }
            }
        }
    }
}
</pre>
<H2>References</H2>
<UL>
<li><a href="http://sourceforge.net/apps/mediawiki/sharppcap/index.php">SharpPcap home page (news / getting started)</a></li>
<LI><A href="http://sourceforge.net/projects/sharppcap" target=_blank>SharpPcap SourceForge project page (File releases / source code)</A>.</li>
<LI><A href="http://www.winpcap.org/" target=_blank>WinPcap</A> - a packet capture framework for Windows.</li>
<li><a href="http://www.tamirgal.com/home/dev.aspx?Item=SharpPcap">Tamir's SharpPcap page (currently out-of-date)</a></li>
</ul>
<H2>History</H2>
<ul>
<li>2010-Nov-07
<ul>
<li>Updated for SharpPcap v3.x</li>
<li>Added queueing example for high packet rates</li>
</ul></li></ul>
<ul>
<li>2010-Jan-27
<ul>
<li>Updated for the current version of SharpPcap, v2.4.0.</li></ul></li></ul>
<UL> 
<li>2005-Nov-27 
<UL> 
<LI>Initial version posted. </LI></UL></LI></UL> 
</body>
</html>